# Where Syntax Meets Semantics

## Definitions ✏️ 

- *Grammar* - A set of rules for constructing parse trees
- *Language* - The set of fringes of all parse trees constructed from a given grammar

## Order Matters!

Take the two following grammars:

```
G2
<subexp> ::= <var> - <subexp> | <var>
<var> ::= a | b | c
```

```
G3
<subexp> ::= <subexp> - <var> | <var>
<var> ::= a | b | c
```

Are they identical?

...

...

...

Well, in one sense: the **fringes** of the 🌳 parse trees 🌳 generated by both grammars are identical.

However, the internal structure of those parse trees is not. i.e. the derivation is NOT identical.

G2:

```
						<subexp>
		<var>				-				<subexp>
		a								<var>	-	<subexp>
										b			<var>
													c
```

G3:

```
							<subexp>
			<subexp>			-			<var>
	<subexp>	-	<var>					c
	<var>			b
	a
```

Basically, this is the difference between:

`(a-(b-c))`

and

`((a-b)-c)`

Which is quite the difference indeed! 😱 (What if `a=1, b=2, c=3`?)

## Operators ➕➖

Most of the basic stuff: operators can refer to both the token (`+`, `++`, `!`, etc) and the operation itself (addition, increment, negation, respectively).

Types:

- Unary operators: take one operand
  - ex: negation `!`
    - `!true` (which equals false)
  - cannot be infix, but can prefix (`!true`) or postfix (`a++`)
- Binary operators: take two operands
  - can be infix, postfix, or prefix
- Ternary operators: three operands

## Precedence 👑 

Take the following grammar G5:

```
G5
<exp> ::= <exp> + <exp> | <multexp>
<multexp> ::= <multexp> * <multexp> | ( <exp> ) | a | b | c
```

You often need complicated rules (per C's 15 different levels) to agree with the human intuition. Sad fact but true 😔 

## Associativity 👨‍👨‍👧‍👦

Even though the above G5 grammar fixes the problem of multiplication precedence it does nothing to fix associativity. For example, what about `a+b+c`? Is it `(a+b)+c` or `a+(b+c)`?

Do 🛑 not 🛑  fall into the trap of thinking "it doesn't matter! They're the same" because a grammar for a language **must** generate only **one** ☝️ parse tree for any given expression. JUST ONE! And anyways, like we saw earlier, `a-(b-c)` isn't the same thing as `(a-b)-c` anyways, so...

Enter the concept of *associativity*. In most languages, when operators have equal precedence, they are called **left-associative** (i.e. `a+b+c` becomes `(a+b)+c`)

However, currently, our grammar G5 has no concept of associativity! Let's fix that:

```
G6
<exp> ::= <exp> + <multexp> | <multexp>
<multexp> ::= <multexp> * <rootexp> | <rootexp>
<rootexp> ::= ( <exp> ) | a | b | c
```

This grammar enforces left-associativity by forcing parse trees to grow down and to the left.

**A left-associative operator requires a left-recursive rule**

**A right-associative operator requires a right-recursive rule**

i.e. `<exp> ::= <exp> + <multexp> | <multexp>` forces the `+` operator to be left-associative because the left side of the operator is recursive, not the right (`<exp> + <multexp>` rather than `<multexp> + <exp>`)

Common right-association operators:

- Assignment operator (`=`)
  - `a=b=1` assigns 1 to both a and b
- Concatentation operator in ML `::`
  - `1::2::[3,4]` - if it was left associative that wouldn't work
- Exponentiation operator `**`

## Ambiguity

A grammar is **ambiguous** if it EVER allows the generation of two different parse trees from the same string.

Grammars should always be unambiguous. 

Is the following grammar for a if-else (with optional else) statement ambiguous?

```
<stmt> ::= <if-stmt> | s1 | s2
<if-stmt> ::= if <exp> then <stmt> else <stmt> | if <exp> then <stmt>
<exp> ::= e1 | E2
```

I'm sure your mind is jumping to "yes" automatically but *why* is it ambiguous?

...

...

...

Take `if e1 then if e2 then s1 else s2`

Does the else belong to the outer or inner `if`?

- `if e1 then (if e2 then s1) else s2`
- `if e1 then (if e2 then s1 else s2)`

This is known as the **danging else problem**

We can fix this by adding a further construct for `<full-stmt>` which can ONLY match an if statement with the `else` present.

## Abstract Syntax Trees 🖼 

Many language systems and parsers do not keep the full, excruciatingly-detailed parse tree in memory, but rather the minimum useful representation. This representation is called the **abstract syntax tree (AST)**. 