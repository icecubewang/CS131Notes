# W10;L2: The Last One

"A record number of topics on lecture"

## Cost Models

Before and during developing software, you should have a **cost model** that accounts for all monetary costs associated with the developmental process.

- Basically, focus on what is important so you can optimize the important stuff and ignore all the other üí© 

A *cost model* is an *approximate* mental model for how programs execute and the costs associated with its development and execution

- Often wrong due to the changing nature of computer science
- Largely intuitive
- Big-O notation talks about scalability of your algorithm ü§ñ 

Many costs!

- Time
  - Real vs CPU
- Memory
  - RAM vs cache vs secondary storage
- Power
  - Power vs energy
- Network access
  - Latency
  - Throughput

### Function Calls ‚òéÔ∏è 

**Assumed to be call by value in the following**

The caller is eagerly evaluating its arguments and now must make copies for the parameters (the specific convetions are machine dependent - on the x86, you copy the first 6 arguments to registers for example)

Now jump to callee!!

Callee must allocate a stack frame, save registers as needed, and execute the function body

The callee also copies its result to the return register (for C there is only one (`%rax`)) and must **de**allocate the frame

Now jump BACK to caller

#### A Complication

Since function calls are like super common, we want them to go as fast as possible.

So people have devised a few different systems

##### Inline Functions

The compiler merely substitutes the callee function's body into the caller

- Pretty common, C/++ have `inline` keyword for example
- Good for small functions where the bodies are small since most of the work for those functions is done in all the overhead (copying arguments and saving registers and allocating stack frames)

BUT** ‚ö†Ô∏è you can't use it all the time!

- Inlining BLOATS the code linearly for every function call
- NO recursion üîÆ 

##### Tail Call Optimization

If `f()` returns `g()` then you can save some steps by

#### Escape Analysis üö™

The compiler looks for üëÄ values that your function might "let out" üè° 

- ex:

```java
class C {
    Point location() { return new Point(x, y); }
    void showLocation() {
        Point p = location();
        system.out.println("@" + p.x + "," + p.y);
    }
}
```

- here `p` is only addressable to the `showLocation()` function (i.e. `p` is only used inside `showLocation` twice (once for x and once for y), never returning `p` or exposing it)
- so! we can do an optimization ‚ö°Ô∏è 
- we can put `p` only on the Java stack, **NOT** on the heap
  - i.e. no garbage collection! üóë üòä 

### Outdated Cost Models

- the keyword `register` in C
  - invented when compilers were dumb and couldn't do register allocation well
- `inline`
  - invented when compilers didn't inline automatically/based on the function