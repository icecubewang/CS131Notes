# W7;L2

## Why Prolog is important

Prolog most closely resembles the bridge between computer science and formal logic. The connection has always been there of course, but Prolog aims to map fairly literately and straight-forwardly.

## Zero-Order Logic/Propositional Logic â¡ï¸ 

Composed of **propositions** ğŸ“ and **connectives** ğŸ“– 

- Propositions ğŸ“ are claims or statements
  - ex: "It is raining"
  - ex: "The 405 is busy"
  - We assign letters to propositions
  - We can represent "It is raining" with the letter `p`
- Connectives ğŸ“– allow us to create relations between propositions
  - AND
  - (INCLUSIVE) OR
  - NOT
  - EXCLUSIVE OR
- We represent propositions and the results of their connectives with **truth tables**

| p    | q    | p ^ q |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 1     |
| 1    | 0    | 1     |
| 1    | 1    | 0     |



Sadly, one of the most important connective was left out of C-based languages: **implies** `â€”>`

### Implies

| p    | q    | p â€”> q |
| ---- | ---- | ------ |
| 0    | 0    | 1      |
| 0    | 1    | 1      |
| 1    | 0    | 0      |
| 1    | 1    | 1      |

- "If it is raining, then the 405 is busy."
  - So the first row of the truth table is *true* because it is NOT raining â˜”ï¸ ğŸ›‘ AND the 405 is NOT busy :pray: 
  - This is only ever FALSE when you guarantee something (it is raining) and the conclusion is FALSE ğŸ˜± 
    - This is basically just lying
    - "If you do this for me, then I'll do this."
    - The only time someone will be mad is if they do something for you (p is true), and you do NOT do the thing for them (q is false) ğŸ˜¡ 

In C, this would be:

```c
p <= q // p implies q
p >= q // p reverse implies q
```

- It's a little strange but think about it! ğŸ§  

You can also have **reverse** implies

| p    | q    | p <â€” q |
| ---- | ---- | ------ |
| 0    | 0    | 1      |
| 0    | 1    | 0      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |

And **bi-conditional**

| p    | q    | p <â€”>q |
| ---- | ---- | ------ |
| 0    | 0    | 1      |
| 0    | 1    | 0      |
| 1    | 0    | 0      |
| 1    | 1    | 1      |

- This is true iff p and q agree

### Tautology âš–ï¸

Tautologies are expressions such that when you create the truth table, **it is all true**/1's

- Basically, being redundant

They can be useful when you want to prove guarantees in software

- ex: Ensuring security in browsers

### Flaws in Logic ğŸ˜±

1. p: All men are mortal
2. q: Socrates is a man
3. r: Socrates is mortal

This statement is *intuitively* true and the only logical thing to conclude, HOWEVER, under propositional logic, the truth table does **not** generate a tautology

| p    | q    | r    | p & q â€”> r |
| ---- | ---- | ---- | ---------- |
| 0    | 0    | 0    | 1          |
| 0    | 0    | 1    | 1          |
| 0    | 1    | 0    | 1          |
| 0    | 1    | 1    | 1          |
| 1    | 0    | 0    | 1          |
| 1    | 0    | 1    | 1          |
| 1    | 1    | 0    | **0**      |
| 1    | 1    | 1    | 1          |

## First-Order Logic/Predicate Calculus ğŸ¤“ 

**Uses logical variables**

- These variables inherently have SCOPE
- Primarily two symbols, also called **quantifiers**
  - for all âˆ€
    - âˆ€X means that for EVERY X in the entire universe, this claim must hold
    - âˆ€X(p(X)) where p(X) means "The freeway X is busy" means that every freeway ever is busy
  - there exists âˆƒ

### Mortality Example â˜ ï¸

$$
\forall X((man(X) \rightarrow mortal(X)) \and man(Socrates)) \rightarrow mortal(Socrates)
$$

### Pros

Using first-order logic allows us to analyze software more rigorously and guarantee security

- In fact, all of Euclid's work can be transformed into first-order logic
- *Can you do the same for software?* ğŸ‘¾ 

Hilbert's program concerns itself with finding an <u>algorithm</u> to verify tautologies

- Proved to be impossible! ğŸ˜ 
- Godel's Incompleteness Theory
  - Connected with Turing's halting problem (you cannot prove that a program will or will not halt execution)

## Clausal Form

A standard way of taking first-order logical formulas and writing them down in restricted versions

- Easier to compare formulas

$$
B_1 \or B_2 \or \dots \or B_N \leftarrow A_1 \and A_2 \and \dots \and A_N
$$

- where every B_i and A_i are single goals with NO connectives
- A1 through AN are **antecedents**
- B1 through BN are the **consequents**
- If every single antecedent is true then AT LEAST one â˜ï¸ of the consequents are true

$$
\forall X(dog(X) \or cat(X) \or pig(X) \leftarrow inSantaMonica(X) \and pet(X) \and licensed(X))
$$

- Since dogs, cats, and pigs ğŸ½ are the only pets you can license, this must be true
- **Notice** âš ï¸! There is only one quantifier
- You can translate this to Prolog!

### Horn Clauses ğŸ 

```prolog
dog(X); cat(X); pig(X) :- inSantaMonica(X), pet(X), licensed(X).
```

- Super cool! The snake eats its own tail ğŸ 
- However! Why are there ORs on the LEFT side???
  - You can't do this in Prolog
  - This is because the creator of Prolog simplified the set of logic he was trying to represent in order to be more readable and easier to use
  - These statements are thus called **Horn clauses**
    - ex: you cannot use ORs on the left hand side in Horn clauses

### Prolog Rules

- You must have only one consequent (Horn clause)
- **Prolog is a subset of first order logic**

| n=1  | m=0  | dog(X).<br />dog(X) :- true.         |
| ---- | ---- | ------------------------------------ |
| n=1  | m>0  | dog(X) :- canine(X), tamed(X).       |
| n=0  | m>0  | ?- dog(fido)<br />false <â€” dog(fido) |

- Prolog operates by **proof through contradiction**
  - It assumes that what you said is <u>TRUE</u>
  - And tries to derive a contradiction from that premise
  - If it cannot derive a contradiction, then your premise must really be true
  - Related to the *resolution principle*

## Problems in Prolog ğŸ˜•

1. Order of execution must be understood
   1. You cannot just magically throw logical statements at it
   2. You must understand the interpreter 

> *The world's dumbest and fastest theorem prover* - Eggert

2. Closed world assumption ğŸ”’ 
   1. Not provable operator `\+` forces the closed world assumption

## Strengths of Prolog ğŸ’ª 

Really good for situations where you know exactly what you want and how to state it logically

Homework 2 (the grammar parser) would've been "4 times easier" in Prolog

- Backtracking built-in

