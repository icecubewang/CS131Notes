# W2;L1

## OCaml vs ML

Lists

- OCaml: `[a;b]`
- ML: `[a,b]`

AND

- OCaml: `&&`
- ML: `and also`

Mostly the same, just surface level differences

## Higher Order Functions 👼 

`let cons(a,b) = a :: b`

Compiler will type infer:

`cons: 'a * 'a list -> a' list = <fun>`

- Takes Something and Something List and returns Something List



`let cons a b = a :: b`

Compiler will type infer:

`cons: 'a -> 'a list -> 'a list = <fun>`

- Takes Something and returns a FUNCTION taking in Something List, which returns Something List

Here, cons is a **higher-order function** returning a function returning a list of the same type that the original argument you passed in was.

```ocaml
cons 3 [5;7] evaluates to (cons 3) [5;7]

# let abra = cons 37;;
abra: int list -> int list = <func>
# abra [12];;
[37; 12]
```

With this latter definition of `cons`, you can **curry** the cons function.

### Sidebar

```ocaml
# let consempty = cons [];;
consempty: 'a list list -> 'a list list
# consempty [[5; 9]; [3; 6; 7]];;
[[]; [5; 9]; [3; 6; 7]]
```

## Lists

### In LISP

#### `car`

AKA *head*

`car [3; 5; 7] -> 3`

#### `cdr`

AKA *tail*

`cdr [3; 5; 7] -> [5; 7]`

### In OCaml

**Patterns** are fundamental in OCaml.

| Pattern     | Matches                                                     |
| ----------- | ----------------------------------------------------------- |
| 0           |                                                             |
| []          | empty list                                                  |
| a           | anything, is binding                                        |
| _           | anything, but forgets it                                    |
| P1, ..., Pn | tuple such that P matches first element and Pn matches last |
| P1 :: P2    | nonempty list s.t. P matches head and P2 matches tail       |

```
let car (x:: _) = x;;
```

The above is a **partial function** - it does not support every possible input of the type specified 

- In this example, `car` does not actually support type `'a list`, for example `[]`



> Languages are not just syntax, they are ways of thinking.



## Patterns 🧶 

```ocaml
(* ann = all non negatives; returns true if list has no negatives*)
let rec ann L =
	if L = []
	then true
	else 0 <= car L && ann (cdr L)
;;

(* OR *)
let rec ann L =
	L = []
	|| (0 <= car L && ann (cdr L))
;;
```

regardless, BOTH are wrong! they are thinking in imperative style

```ocaml
let rec ann L =
	match L with
	| Pattern1 -> Expression1
	| Pattern2 -> Expression2
;;

let rec ann L =
	match L with
	| [] -> true
	| a :: d -> 0 <= a && (ann d)
;;

(* shorthand *)
let rec ann = function
	| [] -> true
	| a :: d -> 0 <= a && (ann d)
;;


```

this is the proper way to do it!! with pattern matching

## Functions in OCaml

```
let cons a = fun b -> a :: b
===
let cons = fun a -> fun b -> a :: b
let cons = (fun a -> (fun b -> a :: b))
```



*Q: Why have both `function` and `fun`?*

A: They are mostly the same.

**function** is designed for pattern matching 🧶 

- `function | [] -> 0 | _ -> 1`
- you can't do this with `fun`
- shorthand for `fun a -> match a with`

**fun** is designed for currying 🍛 

- `fun x y -> x + y`
- you can't do this with `function`





functions in OCaml are **left-associative** to make currying easier and not need parentheses

### Min Element

first attempt...

```ocaml
let rec minlist L =
	match L with
	| [] -> 999999999999999 
	(* ^ should be infinity but that doesn't work for ints*)
	| a :: d -> let md = minlist d in
				if a < md
				then a
				else md
;;
```

we can cut down a little bit since we don't actually need the entire list ever

```ocaml
let rec minlist = function
	| [] -> 999999999999999 
	(* ^ should be infinity but that doesn't work for ints*)
	| a :: d -> let md = minlist d in
				if a < md
				then a
				else md
;;
```

but this is not generalizable! it doesn't work on strings! or floats!

what's keeping it from being general? the `a < d` which forces us to use integer less-than as a method of comparison 🤢 

```ocaml
let rec minlist lt inf = function
	| [] -> inf 
	| a :: d -> let md = minlist d in
				if lt a md
				then a
				else md
;;
```

we now have to supply a "less-than" function (comparison predicate) `lt` and a "infinity" value (to return on empty list) `inf`