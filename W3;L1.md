# W3;L1

## Grammars üìö 

### Notation ‚úèÔ∏è 

1. RegEx
   1. `^a.*b.+c$` matches any line that starts with an `a` followed by any number of characters, then followed by a `b` followed by any non-empty characters, ending with `c`
      1. Think of this as a **pattern**
      2. Or as a grammar, where:

```
S => 'a' chars 'b' non-empty chars 'c'
char => a
char => b
char => c
chars =>
chars => char chars
```

2. Internet RFC notation
   1. trying to standardize what can go onto the internet
   2. there are thousands of RFCs, each specifying a different protocol (specifying what bytes can be transmitted over the network as packets)
   3. these are not language grammars  but rather *data grammars*
   4. ex: Internet RFC 5322

```
Header:
	Message-ID: <eggert23.$fs."abc"@cs.ucla.edu>
Body:
```

where the grammar for this is composed of:

```
Message-ID: "<" word *("." word) "@" atom *("." atom)">"

where
*("." word)
means any number of words separated by periods
```

You can see the similarity to RegEx, but it is technically **EBNF** (extended BNF (Backer-Naus Form))

```
word = atom / quoted-string (where "/" is OR)
```

which you can also express in BNF as:

```
word = atom
word = quoted-string

Message-ID: "<" word dotwords "@" atom dotatoms ">"
dotwords =
### You can also express "emptiness" with an epsilon
dotwords = "." word dotwords

dotatoms =
dotatoms = "." atom dotatoms

atom = 1*<any CHAR exact specials, SPACE, and CTLs>
### ^ This is a nonterminal that stands for a finite set of characters that is known
CTLS (controls) = \000-\037, \177
SPACE = " "

quoted-string = <"> *(qtext / quoted-pair) <">
qtext = <any CHAR except "\CR">
quoted-pair = "\" CHAR
```

You can always take a given EBNF notation and translate it into BNF



‚ö†Ô∏è You can cause **trouble** with these grammars ‚ö†Ô∏è  



How?

You can create a program that generates valid message IDs that conform to this grammar by *using a null-byte `\000` in the message ID*. If the email client is written in C/C++, the function `strcmp` will simply ignore anything after the null byte (since you pass two char pointers to `strcmp` and you do not pass the length of the strings they refer to, the only way strcmp knows where the end is is by the null byte). Thus, you can confuse the email client into not knowing the full ID of the sender (this can be used to hide the true identity of the sender, say in forensic contexts).

