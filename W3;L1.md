# W3;L1

## Grammars ðŸ“š 

### Notation âœï¸ 

1. RegEx
   1. `^a.*b.+c$` matches any line that starts with an `a` followed by any number of characters, then followed by a `b` followed by any non-empty characters, ending with `c`
      1. Think of this as a **pattern**
      2. Or as a grammar, where:

```
S => 'a' chars 'b' non-empty chars 'c'
char => a
char => b
char => c
chars =>
chars => char chars
```

2. Internet RFC notation
   1. trying to standardize what can go onto the internet
   2. there are thousands of RFCs, each specifying a different protocol (specifying what bytes can be transmitted over the network as packets)
   3. these are not language grammars  but rather *data grammars*
   4. ex: Internet RFC 5322

```
Header:
	Message-ID: <eggert23.$fs."abc"@cs.ucla.edu>
Body:
```

where the grammar for this is composed of:

```
Message-ID: "<" word *("." word) "@" atom *("." atom)">"

where
*("." word)
means any number of words separated by periods
```

You can see the similarity to RegEx, but it is technically **EBNF** (extended BNF (Backer-Naus Form))

```
word = atom / quoted-string (where "/" is OR)
```

which you can also express in BNF as:

```
word = atom
word = quoted-string

Message-ID: "<" word dotwords "@" atom dotatoms ">"
dotwords =
### You can also express "emptiness" with an epsilon
dotwords = "." word dotwords

dotatoms =
dotatoms = "." atom dotatoms

atom = 1*<any CHAR exact specials, SPACE, and CTLs>
### ^ This is a nonterminal that stands for a finite set of characters that is known
CTLS (controls) = \000-\037, \177
SPACE = " "

quoted-string = <"> *(qtext / quoted-pair) <">
qtext = <any CHAR except "\CR">
quoted-pair = "\" CHAR
```

You can always take a given EBNF notation and translate it into BNF



âš ï¸ You can cause **trouble** with these grammars âš ï¸  



How?

You can create a program that generates valid message IDs that conform to this grammar by *using a null-byte `\000` in the message ID*. If the email client is written in C/C++, the function `strcmp` will simply ignore anything after the null byte (since you pass two char pointers to `strcmp` and you do not pass the length of the strings they refer to, the only way strcmp knows where the end is is by the null byte). Thus, you can confuse the email client into not knowing the full ID of the sender (this can be used to hide the true identity of the sender, say in forensic contexts).



### RegEx

RegEx is different from BNF grammars in that RegEx does not allow the same level of recursion that BNF does. RegEx has looping instead.

Tail recursive grammars, for example, CAN be turned into regex:

```
S -> a T
T -> b U
U -> c S
U -> d
```

turns into `(abc)*d`

### HW Hint ðŸ”® 

> Look at the grammar. If tail recursive, use the code provided. If not, do more work.

### ISO (International Standardization Organization) ðŸŒ 

There is an ISO standard for JavaScript, C++, etc.

Because ISO standardizes stuff, they have to write specs. Because they also standardize languages, they have to follow a grammar.

*ENTER:* **ISO standard for EBNF**

[ISO ENBF](http://www.cl.com.ac.uk/~mgk25/iso-ebnf)

Listed in *decreasing precedence*

- Double or single quoted
  - `"terminal"`
  - `'terminal'`
  - this allows for double quoting a single quote and singling quoting a double quote as well which is nice
- `[ option ]`
  - 0 or 1 times
- `{ repetition }`
  - 0 or none times
- `( grouping )`
  - 1 time
- `(* comments *)`
  - commenting
- `*` repetition
  - 0 or none times
-  `-` except
  - set difference in a group
- `,` concatentation
  - `A,B` something that matches A and then right next to that, something that matches B
- `|` or
- `LHS = RHS;`
  - grammar rule



#### How to formalize what you CAN put into a grammar and what you cannot

ISO wrote the spec in English, but English can be ambiguous. 

Thus, they wanted a formal notation for their grammar, a way to **define the syntax for ISO EBNF** in a clear and unmistakeable way.

Of course, they *used* ISO EBNF to define ISO EBNF.

```
syntax = syntax rule, { syntax rule };
(* comma above means concatentation *)
(* spaces are allowed in identifier *)

syntax rule = meta id, '=', defns list, ';';
defns list = defn, { "|", defn };
defn = term, { ',', term };
```

This grammar describes itself! For example:

```
syntax rule = meta id, '=', defns list, ';';
```

Is in itself a syntax rule! (an identifier followed by an equals sign, followed by a list of definitions, terminated in a semicolon)

## Syntax/Railroad Charts/Graphs/Diagrams ðŸ›¤ 

Started from the Scheme programming language (inspired JavaScript!)

```
cond => (=> cond 	=(1)=> cond clause => =>) 	=(*)>
					=(2)=> else sequence		*
```

These diagrams can be used to generate parsers.

They can also be example of *finite state machines* or, as in the example above, a *pushdown automaton* (i.e. a finite state machine + a stack). ðŸ¤– â¬‡ï¸ 

In the scope of this course, **context-free** grammars are sufficient to express programming languages/notations. However, they are not enough for natural languages.

- i.e. The singular-plural example from last lecture is easy to do in context-sensitive grammars, but very annoying and verbose to do in context-free

## Ambiguous Grammars ðŸ‘

```
E => E + E
E => E * E
E => NUM
E => (E)
```

This is ambiguous because it can generate **two different derivations/parse trees**

Take:

```
2 + 3 * 4
```

You can say:

```
				E
	E			E			E
	2			+		E		E
						3	* 	4
```

Which is correct, but you can also say

```
2		+		3		*		4
E				E				E
		E					E
				E
```

(2+3) * 4

which we do not want (bc PEMDAS)

The second derivation/parse tree is known as the **wrong node**

We can fix this by complicating our grammar like so:

```
E => E + T
E => T
T => T * F
T => F
F => NUM
F => (E)
```

Now we have added extra constraints to the language that will prevent the derivations we don't want.

- The grammar we defined above says that `+` is left-associative
- Thus **order matters** in a grammar
- If we wanted right-associative addition the first rule should be `E => T + E`

### Types

A *precedence ambiguity* can be fixed by ordering operations in precedence (if you see a parentheses, that has precedence/priority)

An *associativity ambiguity* results from more than one way of deriving a sentence (`a+b+c` can be `(a+b)+c` or `a+(b+c)`)

